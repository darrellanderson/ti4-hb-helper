import {
  FactionSchemaType,
  HomebrewModuleType,
  PlanetAttachmentSchemaType,
  SystemAttachmentSchemaType,
  SystemSchemaType,
} from "ti4-ttpg-ts-types";

import fs from "fs";
import path from "path";

export abstract class AbstractGen {
  private readonly _homebrew: HomebrewModuleType;
  private readonly _filenameToData: Map<string, Buffer> = new Map();
  private _prebuildDir: string = "prebuild";
  private _modDir: string = "assets";

  /**
   * Generate output files, use addOutputFile for each file.
   *
   * Cannot mix abstract and async keywords, but treat this as abstract.
   */
  async generate(errors: Array<string>): Promise<void> {}

  constructor(homebrew: HomebrewModuleType) {
    this._homebrew = homebrew;
  }

  setPrebuildDir(prebuildDir: string): this {
    this._prebuildDir = prebuildDir;
    return this;
  }

  getPrebuildDir(): string {
    return this._prebuildDir;
  }

  setModDir(modDir: string): this {
    this._modDir = modDir;
    return this;
  }

  getModDir(): string {
    return this._modDir;
  }

  addOutputFile(filename: string, data: Buffer): void {
    this._filenameToData.set(filename, data);
  }

  /**
   * Get the list of output files generated by this instance, for testing.
   *
   * @returns An array of output file paths.
   */
  _getOutputFiles(): Array<string> {
    return Array.from(this._filenameToData.keys()).sort();
  }

  getSource(): string {
    return this._homebrew.sourceAndPackageId.source;
  }

  getFactions(): Array<FactionSchemaType> {
    return this._homebrew.factions ?? [];
  }

  getPlanetAttachments(): Array<PlanetAttachmentSchemaType> {
    return this._homebrew.planetAttachments ?? [];
  }

  getSystemAttachments(): Array<SystemAttachmentSchemaType> {
    return this._homebrew.systemAttachments ?? [];
  }

  getSystems(): Array<SystemSchemaType> {
    return this._homebrew.systems ?? [];
  }

  writeOutputFiles(): void {
    const modDir: string = this.getModDir();
    if (!fs.statSync(modDir).isDirectory()) {
      throw new Error(`modDir is not a directory: ${modDir}`);
    }

    const mustStartWith: Set<string> = new Set([
      "Models",
      "Scripts",
      "Templates",
      "Textures",
    ]);

    this._filenameToData.forEach((data: Buffer, filename: string) => {
      const parts: Array<string> = filename.split("/");
      const firstPart: string | undefined = parts[0];
      if (!firstPart || parts.length < 2 || !mustStartWith.has(firstPart)) {
        throw new Error(`Invalid output filename: ${filename}`);
      }
      filename = path.join(modDir, filename);
      const dir: string = path.dirname(filename);
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(filename, data);
    });
  }
}
