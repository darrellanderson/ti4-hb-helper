import {
  FactionSchemaType,
  HomebrewModuleType,
  PlanetAttachmentSchemaType,
  SystemAttachmentSchemaType,
  SystemSchemaType,
  TechSchemaType,
} from "ti4-ttpg-ts";

import fs from "fs";
import path from "path";
import { exec, ExecException, execSync } from "child_process";

export abstract class AbstractGen {
  private readonly _homebrew: HomebrewModuleType;
  private readonly _filenameToData: Map<string, Buffer> = new Map();
  private _prebuildDir: string = "prebuild";

  /**
   * Generate output files, use addOutputFile for each file.
   *
   * Cannot mix abstract and async keywords, but treat this as abstract.
   */
  async generate(errors: Array<string>): Promise<void> {}

  constructor(homebrew: HomebrewModuleType) {
    this._homebrew = homebrew;
  }

  setPrebuildDir(prebuildDir: string): this {
    this._prebuildDir = prebuildDir;
    return this;
  }

  getPrebuildDir(): string {
    return this._prebuildDir;
  }

  addOutputFile(filename: string, data: Buffer): void {
    this._filenameToData.set(filename, data);
  }

  /**
   * Get the list of output files generated by this instance, for testing.
   *
   * @returns An array of output file paths.
   */
  _getOutputFilenames(): ReadonlyArray<string> {
    return Array.from(this._filenameToData.keys()).sort();
  }

  _getOutputFileData(filename: string): Buffer | undefined {
    return this._filenameToData.get(filename);
  }

  getSource(): string {
    return this._homebrew.sourceAndPackageId.source;
  }

  getFactions(): Array<FactionSchemaType> {
    return this._homebrew.factions ?? [];
  }

  getPlanetAttachments(): Array<PlanetAttachmentSchemaType> {
    return this._homebrew.planetAttachments ?? [];
  }

  getSystemAttachments(): Array<SystemAttachmentSchemaType> {
    return this._homebrew.systemAttachments ?? [];
  }

  getSystems(): Array<SystemSchemaType> {
    return this._homebrew.systems ?? [];
  }

  getTechnologies(): Array<TechSchemaType> {
    return this._homebrew.technologies ?? [];
  }

  async writeOutputFiles(): Promise<void> {
    for (let [filename, data] of this._filenameToData.entries()) {
      filename = AbstractGen._validateFilenameOrThrow(filename);
      console.log(`Writing file: ${filename}`);

      const dir: string = path.dirname(filename);
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(filename, data);

      // Sharp PNGs appear to have issues with some players' TTPG.
      // Reencode with another tool.
      if (filename.endsWith(".png")) {
        const tempFilename = filename + ".tmp.png";
        const cmd: string = `/usr/local/bin/magick ${filename} ${tempFilename}`;
        const stdOut = execSync(cmd, { timeout: 5000 });
        console.log("magick output:", stdOut.toString());
        if (!fs.existsSync(tempFilename)) {
          throw new Error(`Temporary file not created: ${tempFilename}`);
        }
        fs.renameSync(tempFilename, filename);
      }
    }
  }

  static _validateFilenameOrThrow(filename: string): string {
    if (!filename.startsWith("assets/")) {
      filename = path.join("assets", filename);
    }

    const mustStartWith: Set<string> = new Set([
      "Models",
      "Scripts",
      "Templates",
      "Textures",
    ]);

    const parts: Array<string> = filename.split("/");
    const firstPart: string | undefined = parts[0];
    const secondPart: string | undefined = parts[1];
    if (!firstPart || firstPart !== "assets") {
      throw new Error(`Output must start with "assets": ${filename}`);
    }
    if (!secondPart || !mustStartWith.has(secondPart)) {
      throw new Error(`Invalid asset directory: ${filename}`);
    }
    return filename;
  }
}
