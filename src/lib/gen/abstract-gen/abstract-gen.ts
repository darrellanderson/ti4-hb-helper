import {
  FactionSchemaType,
  HomebrewModuleType,
  PlanetAttachmentSchemaType,
  SystemAttachmentSchemaType,
  SystemSchemaType,
  TechSchemaType,
} from "ti4-ttpg-ts";

import fs from "fs";
import path from "path";
import { execSync } from "child_process";

export abstract class AbstractGen {
  private readonly _homebrew: HomebrewModuleType;
  private readonly _filenameToData: Map<string, Buffer> = new Map();
  private _prebuildDir: string = "prebuild";

  /**
   * Generate output files, use addOutputFile for each file.
   *
   * Cannot mix abstract and async keywords, but treat this as abstract.
   */
  async generate(errors: Array<string>): Promise<void> {}

  constructor(homebrew: HomebrewModuleType) {
    this._homebrew = homebrew;
  }

  setPrebuildDir(prebuildDir: string): this {
    this._prebuildDir = prebuildDir;
    return this;
  }

  getPrebuildDir(): string {
    return this._prebuildDir;
  }

  addOutputFile(filename: string, data: Buffer): void {
    this._filenameToData.set(filename, data);
  }

  /**
   * Get the list of output files generated by this instance, for testing.
   *
   * @returns An array of output file paths.
   */
  _getOutputFilenames(): ReadonlyArray<string> {
    return Array.from(this._filenameToData.keys()).sort();
  }

  _getOutputFileData(filename: string): Buffer | undefined {
    return this._filenameToData.get(filename);
  }

  getSource(): string {
    return this._homebrew.sourceAndPackageId.source;
  }

  getFactions(): Array<FactionSchemaType> {
    return this._homebrew.factions ?? [];
  }

  getPlanetAttachments(): Array<PlanetAttachmentSchemaType> {
    return this._homebrew.planetAttachments ?? [];
  }

  getSystemAttachments(): Array<SystemAttachmentSchemaType> {
    return this._homebrew.systemAttachments ?? [];
  }

  getSystems(): Array<SystemSchemaType> {
    return this._homebrew.systems ?? [];
  }

  getTechnologies(): Array<TechSchemaType> {
    return this._homebrew.technologies ?? [];
  }

  async writeOutputFiles(): Promise<void> {
    for (let [filename, data] of this._filenameToData.entries()) {
      filename = AbstractGen._validateFilenameOrThrow(filename);
      console.log(`Writing file: ${filename}`);

      const dir: string = path.dirname(filename);
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(filename, data);
      if (!fs.existsSync(filename)) {
        console.error(`File not created: ${filename}`);
      } else if (filename.endsWith(".png")) {
        // Reencode PNG files to avoid issues with some players' TTPG.
        // NO, THIS APPEARS TO BE SOMETHING ELSE IS WRONG.
      }
    }
  }

  static async _redoPngWithRetries(filename: string): Promise<boolean> {
    return new Promise(async (resolve) => {
      // Sharp PNGs appear to have issues with some players' TTPG.
      // Reencode with another tool.
      let retriesRemaining: number = 10;
      while (retriesRemaining > 0) {
        const success: boolean = await AbstractGen._redoPngOnce(filename);
        if (success) {
          console.log(`SUCCESS reencoded PNG: ${filename}`);
          break;
        }
        // Generating too many PNGs can cause some failures, give the process a break.
        retriesRemaining--;
        await new Promise((resolve) => setTimeout(resolve, 20));
      }
    });
  }

  static async _redoPngOnce(filename: string): Promise<boolean> {
    return new Promise((resolve) => {
      const tempFilename = filename + ".tmp.png";
      const cmd: string = `/usr/local/bin/magick ${filename} ${tempFilename}`;
      const stdOut = execSync(cmd, { timeout: 5000 });
      console.log("magick:", `"${cmd}"`, `"${stdOut.toString()}"`);
      if (!fs.existsSync(tempFilename)) {
        console.error(`Temporary file not created: ${tempFilename}`);
        resolve(false);
      } else {
        fs.renameSync(tempFilename, filename);
        resolve(true);
      }
    });
  }

  static _validateFilenameOrThrow(filename: string): string {
    if (!filename.startsWith("assets/")) {
      filename = path.join("assets", filename);
    }

    const mustStartWith: Set<string> = new Set([
      "Models",
      "Scripts",
      "Templates",
      "Textures",
    ]);

    const parts: Array<string> = filename.split(path.sep);
    const firstPart: string | undefined = parts[0];
    const secondPart: string | undefined = parts[1];
    if (!firstPart || firstPart !== "assets") {
      throw new Error(`Output must start with "assets": ${filename}`);
    }
    if (!secondPart || !mustStartWith.has(secondPart)) {
      throw new Error(`Invalid asset directory: ${filename}`);
    }
    return filename;
  }
}
